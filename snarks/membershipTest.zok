//from "hashes/mimc7/mimc7R10" import main as hash
import "./customSponge" as hash
import "hashes/utils/256bitsDirectionHelper" as multiplex

// Merke-Tree inclusion proof for tree depth 3 using SNARK efficient pedersen hashes
// directionSelector => TRUE if current digest is on the rhs of the hash
/*
DApp Function for COMPUTING WITNESS
array[] merkleArray;


listOfNodes, rootNode, provingKey = Election.deployed().then(function(instance) { instance.getMerkleInfo(voteKey) } );
value = oneWayHash(secretKey);
if(index mod 2 == 0) : The index is on the left node
{
	value = hash(value, merkleArray[index+1]);
} else {
	value = hash(merkleArray[index-1], value);
}
index div 2 Drop a layer 



SPONGE TAKES A FIELD ARRAY OF TWO VALUES AS INPUT, SO FOR THE INPUT SECRETKEY, SECRETKEY IS PAIRED WITH 0 TO PERFORM INITIAL HASH


 A node is represented as a number defined over a large 'field'; 
 
INPUT: 
PRIVATE Users Secret Key
PUBLIC Merkle Root,
PRIVATE directionSelecter Array containing boolean values to determine hashing order. T = Right, F = Left
PUBLIC siblingNodes Array is of size treeDepth - 1

*/	



def main(field private secretKey, field merkleRoot, private bool[3] directionSelector, field[30] siblingNodes):


    field currentNode = hash([secretKey,0], k); //Pair hash the secretKey with a static value, select k = 10 (k iterations of Feistel will take place)
    for(field i =0; i < siblingNodes.length; i++){
        if(directionSelector[i] == true){
         /* The currentNodes index is a right child*/
            currentNode = hash([siblingNodes[i],currentNode], k);
        } else {
        /* The currentNodes index is a left child*/
            
            currentNode = hash([currentNode, siblingNodes[i]], k);
        }
    }
    assert(merkleRoot == currentNode);
    return
    

